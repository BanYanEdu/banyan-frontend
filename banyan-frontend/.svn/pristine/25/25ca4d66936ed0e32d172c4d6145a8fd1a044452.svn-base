export var complexObjectFormatter = function (row, cell, cellValue, columnDef, dataContext) {
    if (!columnDef) {
        return '';
    }
    var columnParams = columnDef.params || {};
    var complexFieldLabel = columnParams && columnParams.complexFieldLabel || columnDef.field;
    if (!complexFieldLabel) {
        throw new Error("For the Formatters.complexObject to work properly, you need to tell it which property of the complex object to use.\n      There are 3 ways to provide it:\n      1- via the generic \"params\" with a \"complexFieldLabel\" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', params: { complexFieldLabel: 'user.firstName' } }]\n      2- via the generic \"params\" with a \"complexFieldLabel\" and a \"labelKey\" property on your Column Definition, example: this.columnDefs = [{ id: 'user', field: 'user', labelKey: 'firstName' params: { complexFieldLabel: 'user' } }]\n      3- via the field name that includes a dot notation, example: this.columnDefs = [{ id: 'user', field: 'user.firstName'}] ");
    }
    if (columnDef.labelKey && dataContext.hasOwnProperty(complexFieldLabel)) {
        return dataContext[complexFieldLabel] && dataContext[complexFieldLabel][columnDef.labelKey];
    }
    // when complexFieldLabel includes the dot ".", we will do the split and get the value from the complex object
    // however we also need to make sure that the complex objet exist, else we'll return the cell value (original value)
    if (typeof complexFieldLabel === 'string' && complexFieldLabel.indexOf('.') > 0) {
        return complexFieldLabel.split('.').reduce(function (obj, i) { return (obj && obj.hasOwnProperty(i) ? obj[i] : cellValue); }, dataContext);
    }
    return cellValue;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGxleE9iamVjdEZvcm1hdHRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItc2xpY2tncmlkLyIsInNvdXJjZXMiOlsiYXBwL21vZHVsZXMvYW5ndWxhci1zbGlja2dyaWQvZm9ybWF0dGVycy9jb21wbGV4T2JqZWN0Rm9ybWF0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE1BQU0sQ0FBQyxJQUFNLHNCQUFzQixHQUFjLFVBQUMsR0FBVyxFQUFFLElBQVksRUFBRSxTQUFjLEVBQUUsU0FBaUIsRUFBRSxXQUFnQjtJQUM5SCxJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ2QsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDO0lBQzVDLElBQU0saUJBQWlCLEdBQUcsWUFBWSxJQUFJLFlBQVksQ0FBQyxpQkFBaUIsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDO0lBRTVGLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtRQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLCt0QkFJMkcsQ0FBQyxDQUFDO0tBQzlIO0lBRUQsSUFBSSxTQUFTLENBQUMsUUFBUSxJQUFJLFdBQVcsQ0FBQyxjQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBRTtRQUN2RSxPQUFPLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM3RjtJQUVELDhHQUE4RztJQUM5RyxvSEFBb0g7SUFDcEgsSUFBSSxPQUFPLGlCQUFpQixLQUFLLFFBQVEsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQy9FLE9BQU8saUJBQWlCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFDLEdBQUcsRUFBRSxDQUFDLElBQUssT0FBQSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFuRCxDQUFtRCxFQUFFLFdBQVcsQ0FBQyxDQUFDO0tBQzFIO0lBQ0QsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sdW1uIH0gZnJvbSAnLi8uLi9tb2RlbHMvY29sdW1uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGb3JtYXR0ZXIgfSBmcm9tICcuLy4uL21vZGVscy9mb3JtYXR0ZXIuaW50ZXJmYWNlJztcblxuZXhwb3J0IGNvbnN0IGNvbXBsZXhPYmplY3RGb3JtYXR0ZXI6IEZvcm1hdHRlciA9IChyb3c6IG51bWJlciwgY2VsbDogbnVtYmVyLCBjZWxsVmFsdWU6IGFueSwgY29sdW1uRGVmOiBDb2x1bW4sIGRhdGFDb250ZXh0OiBhbnkpID0+IHtcbiAgaWYgKCFjb2x1bW5EZWYpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBjb2x1bW5QYXJhbXMgPSBjb2x1bW5EZWYucGFyYW1zIHx8IHt9O1xuICBjb25zdCBjb21wbGV4RmllbGRMYWJlbCA9IGNvbHVtblBhcmFtcyAmJiBjb2x1bW5QYXJhbXMuY29tcGxleEZpZWxkTGFiZWwgfHwgY29sdW1uRGVmLmZpZWxkO1xuXG4gIGlmICghY29tcGxleEZpZWxkTGFiZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZvciB0aGUgRm9ybWF0dGVycy5jb21wbGV4T2JqZWN0IHRvIHdvcmsgcHJvcGVybHksIHlvdSBuZWVkIHRvIHRlbGwgaXQgd2hpY2ggcHJvcGVydHkgb2YgdGhlIGNvbXBsZXggb2JqZWN0IHRvIHVzZS5cbiAgICAgIFRoZXJlIGFyZSAzIHdheXMgdG8gcHJvdmlkZSBpdDpcbiAgICAgIDEtIHZpYSB0aGUgZ2VuZXJpYyBcInBhcmFtc1wiIHdpdGggYSBcImNvbXBsZXhGaWVsZExhYmVsXCIgcHJvcGVydHkgb24geW91ciBDb2x1bW4gRGVmaW5pdGlvbiwgZXhhbXBsZTogdGhpcy5jb2x1bW5EZWZzID0gW3sgaWQ6ICd1c2VyJywgZmllbGQ6ICd1c2VyJywgcGFyYW1zOiB7IGNvbXBsZXhGaWVsZExhYmVsOiAndXNlci5maXJzdE5hbWUnIH0gfV1cbiAgICAgIDItIHZpYSB0aGUgZ2VuZXJpYyBcInBhcmFtc1wiIHdpdGggYSBcImNvbXBsZXhGaWVsZExhYmVsXCIgYW5kIGEgXCJsYWJlbEtleVwiIHByb3BlcnR5IG9uIHlvdXIgQ29sdW1uIERlZmluaXRpb24sIGV4YW1wbGU6IHRoaXMuY29sdW1uRGVmcyA9IFt7IGlkOiAndXNlcicsIGZpZWxkOiAndXNlcicsIGxhYmVsS2V5OiAnZmlyc3ROYW1lJyBwYXJhbXM6IHsgY29tcGxleEZpZWxkTGFiZWw6ICd1c2VyJyB9IH1dXG4gICAgICAzLSB2aWEgdGhlIGZpZWxkIG5hbWUgdGhhdCBpbmNsdWRlcyBhIGRvdCBub3RhdGlvbiwgZXhhbXBsZTogdGhpcy5jb2x1bW5EZWZzID0gW3sgaWQ6ICd1c2VyJywgZmllbGQ6ICd1c2VyLmZpcnN0TmFtZSd9XSBgKTtcbiAgfVxuXG4gIGlmIChjb2x1bW5EZWYubGFiZWxLZXkgJiYgZGF0YUNvbnRleHQuaGFzT3duUHJvcGVydHkoY29tcGxleEZpZWxkTGFiZWwpKSB7XG4gICAgcmV0dXJuIGRhdGFDb250ZXh0W2NvbXBsZXhGaWVsZExhYmVsXSAmJiBkYXRhQ29udGV4dFtjb21wbGV4RmllbGRMYWJlbF1bY29sdW1uRGVmLmxhYmVsS2V5XTtcbiAgfVxuXG4gIC8vIHdoZW4gY29tcGxleEZpZWxkTGFiZWwgaW5jbHVkZXMgdGhlIGRvdCBcIi5cIiwgd2Ugd2lsbCBkbyB0aGUgc3BsaXQgYW5kIGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgY29tcGxleCBvYmplY3RcbiAgLy8gaG93ZXZlciB3ZSBhbHNvIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGNvbXBsZXggb2JqZXQgZXhpc3QsIGVsc2Ugd2UnbGwgcmV0dXJuIHRoZSBjZWxsIHZhbHVlIChvcmlnaW5hbCB2YWx1ZSlcbiAgaWYgKHR5cGVvZiBjb21wbGV4RmllbGRMYWJlbCA9PT0gJ3N0cmluZycgJiYgY29tcGxleEZpZWxkTGFiZWwuaW5kZXhPZignLicpID4gMCkge1xuICAgIHJldHVybiBjb21wbGV4RmllbGRMYWJlbC5zcGxpdCgnLicpLnJlZHVjZSgob2JqLCBpKSA9PiAob2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eShpKSA/IG9ialtpXSA6IGNlbGxWYWx1ZSksIGRhdGFDb250ZXh0KTtcbiAgfVxuICByZXR1cm4gY2VsbFZhbHVlO1xufTtcbiJdfQ==