import { mapMomentDateFormatWithFieldType } from '../services/utilities';
import * as moment_ from 'moment-mini';
const moment = moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
/**
 * Find the option value from the following (in order of execution)
 * 1- Column Definition "params"
 * 2- Grid Options "formatterOptions"
 * 3- nothing found, return default value provided
 */
export function getValueFromParamsOrGridOptions(optionName, columnDef, grid, defaultValue) {
    const gridOptions = ((grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {});
    const params = columnDef && columnDef.params;
    if (params && params.hasOwnProperty(optionName)) {
        return params[optionName];
    }
    else if (gridOptions.formatterOptions && gridOptions.formatterOptions.hasOwnProperty(optionName)) {
        return gridOptions.formatterOptions[optionName];
    }
    return defaultValue;
}
/** From a FieldType, return the associated date Formatter */
export function getAssociatedDateFormatter(fieldType, defaultSeparator) {
    const defaultDateFormat = mapMomentDateFormatWithFieldType(fieldType);
    return (row, cell, value, columnDef, dataContext, grid) => {
        const gridOptions = ((grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {});
        const customSeparator = gridOptions && gridOptions.formatterOptions && gridOptions.formatterOptions.dateSeparator || defaultSeparator;
        const isDateValid = moment(value, defaultDateFormat, false).isValid();
        let outputDate = (value && isDateValid) ? moment(value).format(defaultDateFormat) : value;
        // user can customize the separator through the "formatterOptions"
        // if that is the case we need to replace the default "/" to the new separator
        if (outputDate && customSeparator !== defaultSeparator) {
            const regex = new RegExp(defaultSeparator, 'ig'); // find separator globally
            outputDate = outputDate.replace(regex, customSeparator);
        }
        return outputDate;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0dGVyVXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1zbGlja2dyaWQvIiwic291cmNlcyI6WyJhcHAvbW9kdWxlcy9hbmd1bGFyLXNsaWNrZ3JpZC9mb3JtYXR0ZXJzL2Zvcm1hdHRlclV0aWxpdGllcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RSxPQUFPLEtBQUssT0FBTyxNQUFNLGFBQWEsQ0FBQztBQUN2QyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxzSEFBc0g7QUFFOUk7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsK0JBQStCLENBQUMsVUFBa0IsRUFBRSxTQUFpQixFQUFFLElBQVMsRUFBRSxZQUFrQjtJQUNsSCxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLE9BQU8sSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQWUsQ0FBQztJQUM3RyxNQUFNLE1BQU0sR0FBRyxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQztJQUU3QyxJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQy9DLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQzNCO1NBQU0sSUFBSSxXQUFXLENBQUMsZ0JBQWdCLElBQUksV0FBVyxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUNsRyxPQUFPLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUNqRDtJQUNELE9BQU8sWUFBWSxDQUFDO0FBQ3RCLENBQUM7QUFFRCw2REFBNkQ7QUFDN0QsTUFBTSxVQUFVLDBCQUEwQixDQUFDLFNBQW9CLEVBQUUsZ0JBQXdCO0lBQ3ZGLE1BQU0saUJBQWlCLEdBQUcsZ0NBQWdDLENBQUMsU0FBUyxDQUFDLENBQUM7SUFFdEUsT0FBTyxDQUFDLEdBQVcsRUFBRSxJQUFZLEVBQUUsS0FBVSxFQUFFLFNBQWlCLEVBQUUsV0FBZ0IsRUFBRSxJQUFTLEVBQUUsRUFBRTtRQUMvRixNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLE9BQU8sSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQWUsQ0FBQztRQUM3RyxNQUFNLGVBQWUsR0FBRyxXQUFXLElBQUksV0FBVyxDQUFDLGdCQUFnQixJQUFJLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLElBQUksZ0JBQWdCLENBQUM7UUFFdEksTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0RSxJQUFJLFVBQVUsR0FBRyxDQUFDLEtBQUssSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFFMUYsa0VBQWtFO1FBQ2xFLDhFQUE4RTtRQUM5RSxJQUFJLFVBQVUsSUFBSSxlQUFlLEtBQUssZ0JBQWdCLEVBQUU7WUFDdEQsTUFBTSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQywwQkFBMEI7WUFDNUUsVUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1NBQ3pEO1FBRUQsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbHVtbiwgRmllbGRUeXBlLCBGb3JtYXR0ZXIsIEdyaWRPcHRpb24gfSBmcm9tICcuLi9tb2RlbHMvaW5kZXgnO1xuaW1wb3J0IHsgbWFwTW9tZW50RGF0ZUZvcm1hdFdpdGhGaWVsZFR5cGUgfSBmcm9tICcuLi9zZXJ2aWNlcy91dGlsaXRpZXMnO1xuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQtbWluaSc7XG5jb25zdCBtb21lbnQgPSBtb21lbnRfOyAvLyBwYXRjaCB0byBmaXggcm9sbHVwIFwibW9tZW50IGhhcyBubyBkZWZhdWx0IGV4cG9ydFwiIGlzc3VlLCBkb2N1bWVudCBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy82NzBcblxuLyoqXG4gKiBGaW5kIHRoZSBvcHRpb24gdmFsdWUgZnJvbSB0aGUgZm9sbG93aW5nIChpbiBvcmRlciBvZiBleGVjdXRpb24pXG4gKiAxLSBDb2x1bW4gRGVmaW5pdGlvbiBcInBhcmFtc1wiXG4gKiAyLSBHcmlkIE9wdGlvbnMgXCJmb3JtYXR0ZXJPcHRpb25zXCJcbiAqIDMtIG5vdGhpbmcgZm91bmQsIHJldHVybiBkZWZhdWx0IHZhbHVlIHByb3ZpZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZyb21QYXJhbXNPckdyaWRPcHRpb25zKG9wdGlvbk5hbWU6IHN0cmluZywgY29sdW1uRGVmOiBDb2x1bW4sIGdyaWQ6IGFueSwgZGVmYXVsdFZhbHVlPzogYW55KSB7XG4gIGNvbnN0IGdyaWRPcHRpb25zID0gKChncmlkICYmIHR5cGVvZiBncmlkLmdldE9wdGlvbnMgPT09ICdmdW5jdGlvbicpID8gZ3JpZC5nZXRPcHRpb25zKCkgOiB7fSkgYXMgR3JpZE9wdGlvbjtcbiAgY29uc3QgcGFyYW1zID0gY29sdW1uRGVmICYmIGNvbHVtbkRlZi5wYXJhbXM7XG5cbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuaGFzT3duUHJvcGVydHkob3B0aW9uTmFtZSkpIHtcbiAgICByZXR1cm4gcGFyYW1zW29wdGlvbk5hbWVdO1xuICB9IGVsc2UgaWYgKGdyaWRPcHRpb25zLmZvcm1hdHRlck9wdGlvbnMgJiYgZ3JpZE9wdGlvbnMuZm9ybWF0dGVyT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb25OYW1lKSkge1xuICAgIHJldHVybiBncmlkT3B0aW9ucy5mb3JtYXR0ZXJPcHRpb25zW29wdGlvbk5hbWVdO1xuICB9XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKiBGcm9tIGEgRmllbGRUeXBlLCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgZGF0ZSBGb3JtYXR0ZXIgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3NvY2lhdGVkRGF0ZUZvcm1hdHRlcihmaWVsZFR5cGU6IEZpZWxkVHlwZSwgZGVmYXVsdFNlcGFyYXRvcjogc3RyaW5nKTogRm9ybWF0dGVyIHtcbiAgY29uc3QgZGVmYXVsdERhdGVGb3JtYXQgPSBtYXBNb21lbnREYXRlRm9ybWF0V2l0aEZpZWxkVHlwZShmaWVsZFR5cGUpO1xuXG4gIHJldHVybiAocm93OiBudW1iZXIsIGNlbGw6IG51bWJlciwgdmFsdWU6IGFueSwgY29sdW1uRGVmOiBDb2x1bW4sIGRhdGFDb250ZXh0OiBhbnksIGdyaWQ6IGFueSkgPT4ge1xuICAgIGNvbnN0IGdyaWRPcHRpb25zID0gKChncmlkICYmIHR5cGVvZiBncmlkLmdldE9wdGlvbnMgPT09ICdmdW5jdGlvbicpID8gZ3JpZC5nZXRPcHRpb25zKCkgOiB7fSkgYXMgR3JpZE9wdGlvbjtcbiAgICBjb25zdCBjdXN0b21TZXBhcmF0b3IgPSBncmlkT3B0aW9ucyAmJiBncmlkT3B0aW9ucy5mb3JtYXR0ZXJPcHRpb25zICYmIGdyaWRPcHRpb25zLmZvcm1hdHRlck9wdGlvbnMuZGF0ZVNlcGFyYXRvciB8fCBkZWZhdWx0U2VwYXJhdG9yO1xuXG4gICAgY29uc3QgaXNEYXRlVmFsaWQgPSBtb21lbnQodmFsdWUsIGRlZmF1bHREYXRlRm9ybWF0LCBmYWxzZSkuaXNWYWxpZCgpO1xuICAgIGxldCBvdXRwdXREYXRlID0gKHZhbHVlICYmIGlzRGF0ZVZhbGlkKSA/IG1vbWVudCh2YWx1ZSkuZm9ybWF0KGRlZmF1bHREYXRlRm9ybWF0KSA6IHZhbHVlO1xuXG4gICAgLy8gdXNlciBjYW4gY3VzdG9taXplIHRoZSBzZXBhcmF0b3IgdGhyb3VnaCB0aGUgXCJmb3JtYXR0ZXJPcHRpb25zXCJcbiAgICAvLyBpZiB0aGF0IGlzIHRoZSBjYXNlIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgZGVmYXVsdCBcIi9cIiB0byB0aGUgbmV3IHNlcGFyYXRvclxuICAgIGlmIChvdXRwdXREYXRlICYmIGN1c3RvbVNlcGFyYXRvciAhPT0gZGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGRlZmF1bHRTZXBhcmF0b3IsICdpZycpOyAvLyBmaW5kIHNlcGFyYXRvciBnbG9iYWxseVxuICAgICAgb3V0cHV0RGF0ZSA9IG91dHB1dERhdGUucmVwbGFjZShyZWdleCwgY3VzdG9tU2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0RGF0ZTtcbiAgfTtcbn1cbiJdfQ==